 										**----Verilog:----**Explain module, port list, and port directions.A module is the basic building block in Verilog. It represents a hardware block.The port list defines what signals come in and go out.Port directions are:• input – signals coming into the module• output – signals going out• inout – bidirectional signalsModules allow hierarchy by instantiating sub-modules inside larger designs.What are different types of delays in Verilog?Three main types:• Inertial delay – blocks glitches; commonly used in continuous assignments.• Transport delay – passes every scheduled event.• Non-synthesizable delays (#5) – used only in testbenches to model timing behavior.In real RTL, we generally avoid delays for synthesis.Difference between blocking (=) and non-blocking (<=) assignments.Blocking executes statements in order, like software.Non-blocking schedules the update at the end of the time step, allowing parallel updates.We use non-blocking for sequential logic and blocking for combinational logic. This avoids race conditions.Non-blocking scheduling:All RHS values are sampled at the event edge.Updates happen only after the block finishes.This avoids ordering issues and lets registers behave together.# **9. Mixing blocking and non-blocking**It creates race conditions because blocking updates immediately and non-blocking waits. Simulation and synthesis may differ. Best rule: use blocking in combinational, non-blocking in sequential, don’t mix in the same block.---# **2. always @(*) vs always @(posedge clk)**`always @(\\\*)` is for combinational logic. It triggers whenever any input changes.`always @(posedge clk)` is for sequential logic. It updates only on the clock edge.If combinational logic uses a clocked block, it forms a latch or flip-flop unintentionally.---wire vs reg`wire` represents a physical connection. It needs a continuous assignment.`reg` stores a value and can be assigned in an always block.In SystemVerilog, `logic` replaces both.---What is the purpose of initial and always blocks?The initial block runs once at time zero. It’s mainly used in testbenches.The always block runs continuously as long as the simulation is active. It’s used for combinational logic, sequential logic, and clock-based behavior.Example: always @(posedge clk) is for flip-flops.How unintentional latches formA latch forms when a combinational block doesn’t assign all outputs for all conditions.Example:```verilogalways @(\\\*) begin\&nbsp;  if (en) q = d; // no else → latchend```Because q must hold its previous value, synthesis infers a latch.How do you avoid latches in Verilog?Latches appear when combinational blocks don’t assign all outputs in every condition.To avoid them:• use @(*) for combinational blocks• provide default assignments at the start of the block• cover all branches of if-else or case statementsSynthesis tools warn when latch inference occurs.---What is combinational vs sequential logic in Verilog?Combinational logic depends only on current inputs. It is written using always @(*).Sequential logic depends on previous values and clock edges. It’s written using always @(posedge clk) or @(negedge clk).Combinational logic maps to gates, while sequential logic maps to flip-flops and latches# **5. Combinational vs sequential always blocks**Combinational: uses `always @(\\\*)`, blocking assignments, covers all conditions, no storage.Sequential: uses `always @(posedge clk)` with non-blocking assignments. It stores data on clock edges.---1. How do you write a synchronous and asynchronous reset?Synchronous reset:The reset is checked only at the clock edge.It’s reliable for synthesis and avoids glitches.Used when reset timing is well-controlled.Asynchronous reset:The reset can trigger anytime, independent of the clock.It’s faster and useful for bringing the design to a known state at power-up.But it needs clean reset release to avoid metastability.12. What is a race condition in Verilog?A race condition happens when two parallel always blocks or two assignments try to update the same signal in the same time step. The final value becomes unpredictable.Using blocking in sequential logic or mixing both styles inside the same block often creates races.We avoid this by using non-blocking for sequential logic and separating combinational logic into different always blocks.---13. What is case, casez, and casex?case:Compares every bit exactly.Best choice for synthesis.casez:Allows Z and ? as don’t-care bits.Useful in decoders and pattern matching.casex:Treats both X and Z as don’t-care.Not recommended for RTL because it can hide unknowns during simulation.---11. Synthesizable vs non-synthesizableSynthesizable code maps to hardware: flip-flops, gates, muxes.Non-synthesizable code is for simulation: delays (#5), forks, system tasks, randomization.Synthesis tools ignore anything that cannot map to hardware.---12. Sensitivity listIt tells the simulator when to run the block.If it's incomplete, simulation mismatches synthesis and creates latches or stale values.`always @(\\\*)` avoids that.---What is parameter and localparam?parameter:Used to define configurable values like width or depth.Can be overridden during instantiation.localparam:Same as parameter but cannot be overridden.Used to protect constants inside a module.Example:parameter WIDTH = 8;localparam COUNT_MAX = 15;Parameters let you write reusable and scalable modules.Example:```verilogmodule adder #(parameter N=8) (input \\\[N-1:0] a,b, output \\\[N-1:0] y);assign y = a + b;endmodule```---Difference between function and task.Function:• returns a single value• no delays allowed• executes in zero simulation time• good for small combinational logicTask:• can return multiple values through output arguments• can include delays• can be used for testbench activities• good for complex operations19. Generate blockUsed for repetitive hardware creation.Example:genvar i;generate   for(i=0;i<8;i=i+1)      assign y[i] = a[i] & b[i];endgenerate```---\*\*# \\\*\\\*20. Missing default in case\\\*\\\*\*\*If you miss some cases, synthesis infers a latch because the output must hold its old value.Always write a default to avoid storage.---\*\*Difference between RTL, gate-level, and behavioral modeling.\*\*Behavioral:Describes high-level behavior without hardware detail.Used in testbenches.RTL:Describes registers and combinational logic.Used for synthesis.Gate-level:Describes actual gates, cells and netlists.Used for timing simulation after synthesis.---\*\*What are $display, $monitor, and $dumpvars?\*\*All are simulation-only system tasks:`$time` gives current time.• $display prints values once when called• $monitor prints whenever any variable changes.• $dumpvars generates waveform data for GTKWave or similar toolsThese help debug testbench behavior---\*\*How do you write a basic testbench?\*\*A testbench has no ports and includes:• signal declarations• DUT instantiation• stimulus using initial blocks• $display or waveform dumping---\*\*How does blocking inside functions work?\*\*Functions execute in order with blocking assignments because they represent combinational logic.They also complete in zero time.Inside a function, every statement must be deterministic and drive something immediately.No timing controls are allowed.\\# \\\*\\\*30. Race conditions\\\*\\\*When two always blocks update or read the same signal at the same time, simulation becomes unpredictable.Avoid it by using non-blocking for all flip-flops, not driving one signal from multiple blocks, and keeping clear separation between stages.---\*\*Common synthesis issues (latches, unconnected nets, width mismatch).\*\*Typical problems seen during synthesis:• Latch inference due to incomplete assignments• Width mismatch when connecting signals of different sizes• Unconnected ports (dangling wires)• Multiple drivers on the same net• Combinational loops causing instability• Async reset issues causing metastabilityThese warnings help identify RTL bugs early.